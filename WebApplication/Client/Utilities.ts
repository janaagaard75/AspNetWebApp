module CocaineCartels {
    "use strict";

    export class Utilities {
        public static addClass(elementId: string, className: string) {
            this.getElement(elementId).classList.add(className);
        }

        public static disableElement(elementId: string) {
            this.getElement(elementId).setAttribute("disabled", "disabled");
        }

        public static enableElement(elementId: string) {
            this.getElement(elementId).removeAttribute("disabled");
        }

        public static getElement(elementId: string): HTMLElement {
            const element = document.getElementById(elementId);
            return element;
        }

        public static flatten<T>(doubleArray: Array<Array<T>>): Array<T> {
            const flattened = Array.prototype.concat.apply([], doubleArray);
            return flattened;
        }

        public static getUrlParameters(): IUrlParameters {
            var pl = /\+/g;  // Regex for replacing addition symbol with a space
            const search = /([^&=]+)=?([^&]*)/g;
            const decode = s => decodeURIComponent(s.replace(pl, " "));
            const query = window.location.search.substring(1);
            const parameters: IUrlParameters = {};

            let match: RegExpExecArray;
            while ((match = search.exec(query))) {
                parameters[decode(match[1])] = decode(match[2]);
            }

            return parameters;
        }

        /** Groups elements in array by a key generated by groupByFunc. (You can use JSON.stingify to in the groupByFunc to convert any object in to a string. */
        public static groupBy<T>(array: Array<T>, groupByFunc: IGroupByFunc<T>): IGroups<T> {
            var associativeArray: IGroups<T> = {};
            array.forEach(item => {
                var key: string = groupByFunc(item);
                if (associativeArray[key] === undefined) {
                    associativeArray[key] = [];
                }
                associativeArray[key].push(item);
            });
            return associativeArray;
        }

        public static groupByIntoArray<T>(array: Array<T>, groupByFunc: IGroupByFunc<T>): Array<Array<T>> {
            const associativeArray = Utilities.groupBy(array, groupByFunc);
            const doubleArray = Utilities.toDoubleArray(associativeArray);
            return doubleArray;
        }

        /** Returns the points halfway between a and b. */
        public static midPoint(a: Konva.Vector2d, b: Konva.Vector2d): Pos {
            const mid = new Pos(
                (a.x + b.x) / 2,
                (a.y + b.y) / 2
            );
            return mid;
        }

        public static removeClass(elementId: string, className: string) {
            this.getElement(elementId).classList.remove(className);
        }

        /** Treats a position as a 2D vector with (0,0) as origin and returns a new vector that is rotated 90 degrees counter clockwize. */
        public static rotate90Degrees(vector: Konva.Vector2d): Pos {
            const rotated = new Pos(
                -vector.y,
                vector.x
            );
            return rotated;
        }

        /** Converts an associative array to a double array. They keys are deleted in the process. */
        public static toDoubleArray<T>(associativeArray: IGroups<T>): Array<Array<T>> {
            const doubleArray = Object.keys(associativeArray).map(group => {
                return associativeArray[group];
            });
            return doubleArray;
        }

        /** Returns a union of two arrays of the same type that does not contain any duplicate items. */
        public static union<T>(array1: Array<T>, array2: Array<T>): Array<T> {
            var union: Array<T> = [];
            array1.forEach(item => {
                if (union.filter(i => i === item).length === 0) {
                    union.push(item);
                }
            });

            array2.forEach(item => {
                if (union.filter(i => i === item).length === 0) {
                    union.push(item);
                }
            });

            return union;
        }
    }
}
